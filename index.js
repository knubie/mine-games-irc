// Generated by CoffeeScript 1.4.0
(function() {
  var Armor, Card, Gem, Item, Monster, Player, Weapon, bot, card_info, cards, check_turn, config, generate_cards, irc, join, list_hand, mine, mine_card, msg, next_turn, player_nicks, players, start, started, turn,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  require('./lib/extend.js');

  players = [];

  player_nicks = [];

  started = false;

  mine = [];

  turn = 0;

  Player = (function() {

    function Player(name) {
      this.name = name;
      this.deck = [];
      this.hp = 100;
      this.level = 1;
      this.attack = 3;
      this.dead = false;
      this.hand = [];
      this.stats = {
        level: this.level,
        attack: this.attack,
        mine: 0,
        value: 0,
        defense: 0
      };
    }

    Player.prototype.addCards = function(cards) {
      var card, _i, _len, _results;
      if (cards.length) {
        _results = [];
        for (_i = 0, _len = cards.length; _i < _len; _i++) {
          card = cards[_i];
          _results.push(this.deck.push(card));
        }
        return _results;
      } else {
        return this.deck.push(cards);
      }
    };

    Player.prototype.draw = function() {
      var card;
      card = this.deck.pop();
      this.hand.push(card);
      this.stats.attack += card.attack;
      this.stats.mine += card.mine;
      return this.stats.value += card.value;
    };

    Player.prototype.discard = function(i) {
      return this.deck.push(this.hand.splice(i, 1));
    };

    Player.prototype.deal = function() {
      var i, _i, _results;
      _results = [];
      for (i = _i = 1; _i <= 5; i = ++_i) {
        _results.push(this.draw());
      }
      return _results;
    };

    return Player;

  })();

  Card = (function() {

    function Card(options) {
      this.name = options.name || 'No name';
      this.cost = 0;
      this.value = 0;
      this.actions = [];
      this.attack = 0;
      this.defense = 0;
      this.mine = 0;
      this.level = 0;
      this.init(options);
    }

    return Card;

  })();

  Gem = (function(_super) {

    __extends(Gem, _super);

    function Gem() {
      return Gem.__super__.constructor.apply(this, arguments);
    }

    Gem.prototype.init = function(options) {
      this.type = 'gem';
      return this.value = options.value;
    };

    return Gem;

  })(Card);

  Weapon = (function(_super) {

    __extends(Weapon, _super);

    function Weapon() {
      return Weapon.__super__.constructor.apply(this, arguments);
    }

    Weapon.prototype.init = function(options) {
      this.type = 'weapon';
      this.attack = options.attack;
      return this.cost = options.cost;
    };

    return Weapon;

  })(Card);

  Armor = (function(_super) {

    __extends(Armor, _super);

    function Armor() {
      return Armor.__super__.constructor.apply(this, arguments);
    }

    Armor.prototype.init = function(options) {
      this.type = 'armor';
      this.defense = options.defense;
      return this.cost = options.cost;
    };

    return Armor;

  })(Card);

  Item = (function(_super) {

    __extends(Item, _super);

    function Item() {
      return Item.__super__.constructor.apply(this, arguments);
    }

    Item.prototype.init = function(options) {
      this.type = 'item';
      this.cost = options.cost;
      return this.mine = options.mine;
    };

    return Item;

  })(Card);

  Monster = (function(_super) {

    __extends(Monster, _super);

    function Monster() {
      return Monster.__super__.constructor.apply(this, arguments);
    }

    Monster.prototype.init = function(options) {
      this.type = 'monster';
      this.level = options.level;
      this.hp = options.hp;
      return this.attack = options.attack;
    };

    return Monster;

  })(Card);

  cards = {
    silver: new Gem({
      name: 'Silver',
      value: 1
    }),
    emerald: new Gem({
      name: 'Emerald',
      value: 2
    }),
    gold: new Gem({
      name: 'Gold',
      value: 3
    }),
    ruby: new Gem({
      name: 'Ruby',
      value: 4
    }),
    diamond: new Gem({
      name: 'Diamond',
      value: 5
    }),
    dagger: new Weapon({
      name: 'Dagger',
      attack: 3,
      cost: 3
    }),
    stone_pick: new Item({
      name: 'Stone Pickaxe',
      cost: 3,
      mine: 1
    }),
    goblin: new Monster({
      name: 'Goblin',
      level: 1,
      hp: 6,
      attack: 3
    })
  };

  generate_cards = function() {
    var i, player, _i, _j, _k, _l, _len, _m, _n, _o, _results;
    for (i = _i = 1; _i <= 40; i = ++_i) {
      mine.push(cards.silver);
    }
    for (i = _j = 1; _j <= 40; i = ++_j) {
      mine.push(cards.goblin);
    }
    for (i = _k = 1; _k <= 30; i = ++_k) {
      mine.push(cards.emerald);
    }
    for (i = _l = 1; _l <= 20; i = ++_l) {
      mine.push(cards.gold);
    }
    for (i = _m = 1; _m <= 10; i = ++_m) {
      mine.push(cards.ruby);
    }
    for (i = _n = 1; _n <= 5; i = ++_n) {
      mine.push(cards.diamond);
    }
    mine.shuffle();
    _results = [];
    for (_o = 0, _len = players.length; _o < _len; _o++) {
      player = players[_o];
      _results.push((function(player) {
        var _p, _q, _r;
        for (i = _p = 1; _p <= 5; i = ++_p) {
          player.deck.push(cards.silver);
        }
        for (i = _q = 1; _q <= 2; i = ++_q) {
          player.deck.push(cards.dagger);
        }
        for (i = _r = 1; _r <= 3; i = ++_r) {
          player.deck.push(cards.stone_pick);
        }
        player.deck.shuffle();
        return player.deal();
      })(player));
    }
    return _results;
  };

  next_turn = function() {
    turn++;
    if (turn >= players.length) {
      turn = 0;
    }
    if (players[turn].dead) {
      return next_turn();
    } else {
      return msg("" + players[turn].name + ": It's your turn!");
    }
  };

  check_turn = function(player, cb) {
    if (turn === players.indexOf(player) && started) {
      return cb();
    }
  };

  join = function(nick) {
    if (__indexOf.call(player_nicks, nick) < 0) {
      players.push(new Player(nick));
      player_nicks.push(nick);
      return msg("" + nick + " joined the game!");
    }
  };

  start = function() {
    if (players.length > 0 && !started) {
      generate_cards();
      msg("Starting game!");
      started = true;
      return next_turn();
    }
  };

  list_hand = function(nick) {
    var card, card_list, player, _fn, _i, _len, _ref;
    if (started) {
      player = players[player_nicks.indexOf(nick)];
      card_list = "";
      _ref = player.hand;
      _fn = function(card) {
        return card_list = "" + card_list + " [" + card.name + "]";
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        _fn(card);
      }
      msg(("" + nick + "'s hand: ") + card_list);
      return msg("      " + nick + "'s stats:       [Lv: " + player.stats.level + "]       [HP: " + player.hp + "]       [Attack: " + player.stats.attack + "]       [Mines: " + player.stats.mine + "]       [Money: " + player.stats.value + "]    ");
    } else {
      return msg("" + nick + ", the game hasn't started yet.");
    }
  };

  mine_card = function(nick) {
    var player;
    player = players[player_nicks.indexOf(nick)];
    return check_turn(player, function() {
      var card;
      if (started && player.stats.mine > 0) {
        player.stats.mine--;
        card = mine.pop();
        msg("You drew a " + card.name + " from the Mine!");
        if (card.type === 'gem') {
          msg("Putting it in your deck.");
          return player.deck.push(card);
        } else {
          if (Math.floor(Math.random())) {
            msg("You attack first, dealing " + player.stats.attack + " damage.");
            if (player.stats.attack >= card.hp) {
              return msg("The " + card.name + " perishes.");
            } else {
              msg("The " + card.name + " counter-attacks for " + (card.attack - player.stats.defense) + " damage.");
              msg("Discarding.");
              return player.hp -= card.attack - player.stats.defense;
            }
          } else {
            msg("The " + card.name + " attacks first, dealing " + card.attack + " damage.");
            msg("Discarding.");
            return player.hp -= card.attack - player.stats.defense;
          }
        }
      }
    });
  };

  card_info = function(text) {
    var card, key, value, _results;
    text = text.toLowerCase();
    _results = [];
    for (key in cards) {
      value = cards[key];
      if (name.toLowerCase() === text) {
        _results.push(card = cards[card]);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  config = {
    channels: ['##mine_games'],
    server: 'irc.freenode.net',
    botName: 'MineGames'
  };

  irc = require('irc');

  bot = new irc.Client(config.server, config.botName, {
    channels: config.channels
  });

  msg = function(text) {
    return bot.say(config.channels[0], text);
  };

  bot.addListener("message", function(from, to, text, message) {
    if (/^[!](.*)$/.test(text)) {
      switch (text.match(/^[!](.*)$/)[1]) {
        case 'join':
          return join(from);
        case 'start':
          return start();
        case 'hand':
          return list_hand(from);
        case 'mine':
          return mine_card(from);
        case 'info':
          return card_info(text.match(/^[!](\S*)\s?(.*)$/)[2]);
      }
    }
  });

}).call(this);

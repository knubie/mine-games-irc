// Generated by CoffeeScript 1.4.0
(function() {
  var Armor, Card, Gem, Item, Monster, Player, Weapon, bot, card_info, cards, check_turn, config, end_turn, generate_cards, help, irc, join, list_hand, mine, mine_card, msg, next_turn, player_nicks, players, start, started, turn, use,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  require('./lib/extend');

  irc = require('irc');

  players = [];

  player_nicks = [];

  started = false;

  mine = [];

  turn = 0;

  Player = (function() {

    function Player(name) {
      this.name = name;
      this.deck = [];
      this.hp = 100;
      this.level = 1;
      this.attack = 3;
      this.dead = false;
      this.hand = [];
      this.stats = {
        level: this.level,
        attack: this.attack,
        mine: 0,
        value: 0,
        defense: 0
      };
    }

    Player.prototype.addCards = function(cards) {
      var card, _i, _len, _results;
      if (cards.length) {
        _results = [];
        for (_i = 0, _len = cards.length; _i < _len; _i++) {
          card = cards[_i];
          _results.push(this.deck.push(card));
        }
        return _results;
      } else {
        return this.deck.push(cards);
      }
    };

    Player.prototype.draw = function(i) {
      var j, _i, _results,
        _this = this;
      if (i == null) {
        i = 1;
      }
      _results = [];
      for (j = _i = 1; 1 <= i ? _i <= i : _i >= i; j = 1 <= i ? ++_i : --_i) {
        _results.push((function() {
          var card;
          card = _this.deck.pop();
          _this.hand.push(card);
          _this.stats.attack += card.attack;
          _this.stats.mine += card.mine;
          return _this.stats.value += card.value;
        })());
      }
      return _results;
    };

    Player.prototype.discard = function(c) {
      var card;
      card = this.hand.splice(this.hand.indexOf(c), 1)[0];
      this.deck.push(card);
      this.stats.attack -= card.attack;
      this.stats.mine -= card.mine;
      return this.stats.value -= card.value;
    };

    Player.prototype.deal = function() {
      return this.draw(5);
    };

    return Player;

  })();

  Card = (function() {

    function Card(options) {
      this.name = options.name || 'No name';
      this.cost = 0;
      this.value = 0;
      this.actions = [];
      this.attack = 0;
      this.defense = 0;
      this.mine = 0;
      this.level = 0;
      this.description = "";
      this.action = function() {
        return msg("That card has no action.");
      };
      this.init(options);
    }

    return Card;

  })();

  Gem = (function(_super) {

    __extends(Gem, _super);

    function Gem() {
      return Gem.__super__.constructor.apply(this, arguments);
    }

    Gem.prototype.init = function(options) {
      var _ref;
      this.type = 'gem';
      this.value = options.value;
      return this.description = (_ref = options.description) != null ? _ref : "Used at the shop to buy more cards.";
    };

    return Gem;

  })(Card);

  Weapon = (function(_super) {

    __extends(Weapon, _super);

    function Weapon() {
      return Weapon.__super__.constructor.apply(this, arguments);
    }

    Weapon.prototype.init = function(options) {
      var _ref;
      this.type = 'weapon';
      this.attack = options.attack;
      this.cost = options.cost;
      return this.description = (_ref = options.description) != null ? _ref : "Can be used to attack Monsters or other Players.";
    };

    return Weapon;

  })(Card);

  Armor = (function(_super) {

    __extends(Armor, _super);

    function Armor() {
      return Armor.__super__.constructor.apply(this, arguments);
    }

    Armor.prototype.init = function(options) {
      var _ref;
      this.type = 'armor';
      this.defense = options.defense;
      this.cost = options.cost;
      return this.description = (_ref = options.description) != null ? _ref : "Used to defend against attacks.";
    };

    return Armor;

  })(Card);

  Item = (function(_super) {

    __extends(Item, _super);

    function Item() {
      return Item.__super__.constructor.apply(this, arguments);
    }

    Item.prototype.init = function(options) {
      this.type = 'item';
      this.cost = options.cost;
      this.mine = options.mine;
      this.action = options.action;
      return this.description = options.description;
    };

    return Item;

  })(Card);

  Monster = (function(_super) {

    __extends(Monster, _super);

    function Monster() {
      return Monster.__super__.constructor.apply(this, arguments);
    }

    Monster.prototype.init = function(options) {
      this.type = 'monster';
      this.level = options.level;
      this.hp = options.hp;
      this.attack = options.attack;
      return this.description = options.description;
    };

    return Monster;

  })(Card);

  cards = {
    silver: new Gem({
      name: 'Silver',
      value: 1
    }),
    emerald: new Gem({
      name: 'Emerald',
      value: 2
    }),
    gold: new Gem({
      name: 'Gold',
      value: 3
    }),
    ruby: new Gem({
      name: 'Ruby',
      value: 4
    }),
    diamond: new Gem({
      name: 'Diamond',
      value: 5
    }),
    dagger: new Weapon({
      name: 'Dagger',
      attack: 3,
      cost: 3
    }),
    stone_pick: new Item({
      name: 'Stone Pickaxe',
      cost: 3,
      mine: 1,
      action: function(player) {
        return mine_card(player);
      }
    }),
    goblin: new Monster({
      name: 'Goblin',
      level: 1,
      hp: 6,
      attack: 3,
      description: "Cretins with big ears and fangs. Strong and stupid."
    })
  };

  generate_cards = function() {
    var i, player, _i, _j, _k, _l, _len, _m, _n, _o, _results;
    for (i = _i = 1; _i <= 40; i = ++_i) {
      mine.push(cards.silver);
    }
    for (i = _j = 1; _j <= 40; i = ++_j) {
      mine.push(cards.goblin);
    }
    for (i = _k = 1; _k <= 30; i = ++_k) {
      mine.push(cards.emerald);
    }
    for (i = _l = 1; _l <= 20; i = ++_l) {
      mine.push(cards.gold);
    }
    for (i = _m = 1; _m <= 10; i = ++_m) {
      mine.push(cards.ruby);
    }
    for (i = _n = 1; _n <= 5; i = ++_n) {
      mine.push(cards.diamond);
    }
    mine.shuffle();
    _results = [];
    for (_o = 0, _len = players.length; _o < _len; _o++) {
      player = players[_o];
      _results.push((function(player) {
        var _p, _q, _r;
        for (i = _p = 1; _p <= 5; i = ++_p) {
          player.deck.push(cards.silver);
        }
        for (i = _q = 1; _q <= 2; i = ++_q) {
          player.deck.push(cards.dagger);
        }
        for (i = _r = 1; _r <= 3; i = ++_r) {
          player.deck.push(cards.stone_pick);
        }
        player.deck.shuffle();
        return player.deal();
      })(player));
    }
    return _results;
  };

  next_turn = function() {
    turn++;
    if (turn >= players.length) {
      turn = 0;
    }
    if (players[turn].dead) {
      return next_turn();
    } else {
      return msg("" + players[turn].name + ": It's your turn!");
    }
  };

  check_turn = function(player, cb) {
    if (turn === players.indexOf(player) && started) {
      return cb();
    }
  };

  join = function(nick) {
    if (__indexOf.call(player_nicks, nick) < 0) {
      players.push(new Player(nick));
      player_nicks.push(nick);
      return msg("" + nick + " joined the game!");
    }
  };

  start = function() {
    if (players.length > 0 && !started) {
      generate_cards();
      msg("Starting game!");
      started = true;
      return next_turn();
    }
  };

  list_hand = function(nick) {
    var card, card_list, player, _fn, _i, _len, _ref;
    if (started) {
      player = players[player_nicks.indexOf(nick)];
      card_list = "";
      _ref = player.hand;
      _fn = function(card) {
        return card_list = "" + card_list + " [" + card.name + "]";
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        _fn(card);
      }
      msg(("" + nick + "'s hand: ") + card_list);
      return msg(("" + nick + "'s stats: ") + ("[Lv: " + player.stats.level + "] ") + ("[HP: " + player.hp + "] ") + ("[Attack: " + player.stats.attack + "] ") + ("[Mines: " + player.stats.mine + "] ") + ("[Money: " + player.stats.value + "]"));
    } else {
      return msg("" + nick + ", the game hasn't started yet.");
    }
  };

  use = function(text, nick) {
    var player;
    player = players[player_nicks.indexOf(nick)];
    return check_turn(player, function() {
      var card, _i, _len, _ref, _results;
      text = text.toLowerCase();
      _ref = player.hand;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        if (card.name.toLowerCase() === text) {
          card.action(player);
          player.discard(card);
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  };

  end_turn = function(nick) {
    var player;
    player = players[player_nicks.indexOf(nick)];
    return check_turn(player, function() {
      var card, _i, _len, _ref;
      _ref = player.hand;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        player.discard(card);
      }
      player.deck.shuffle();
      player.draw(5);
      return next_turn();
    });
  };

  card_info = function(text) {
    var card, key, value, _results;
    text = text.toLowerCase();
    _results = [];
    for (key in cards) {
      value = cards[key];
      if (cards[key].name.toLowerCase() === text) {
        card = cards[key];
        _results.push(msg(("" + card.name + ": ") + ("[\"" + card.description + "\"] ") + ("[type: " + card.type + "] ") + (card.cost !== 0 ? "[cost: " + card.cost + "] " : "") + (card.value !== 0 ? "[value: " + card.value + "] " : "") + (card.attack !== 0 ? "[attack: " + card.attack + "] " : "") + (card.defense !== 0 ? "[defense: " + card.defense + "] " : "") + (card.mine !== 0 ? "[mine: " + card.mine + "] " : "") + (card.level !== 0 ? "[level: " + card.level + "]" : "")));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  help = function() {
    msg("Available commands: ");
    msg("!join: Join the game if it's not already in progress.");
    msg("!start: Start the game.");
    msg("!hand: View your current hand.");
    msg("!info [card name]: View details of a particular card.");
    return msg("!end: End your turn.");
  };

  mine_card = function(player) {
    var card;
    card = mine.pop();
    msg("You drew a " + card.name + " from the Mine!");
    if (card.type === 'gem') {
      msg("Putting it in your deck.");
      return player.deck.push(card);
    } else {
      if (Math.floor(Math.random())) {
        msg("You attack first, dealing " + player.stats.attack + " damage.");
        if (player.stats.attack >= card.hp) {
          return msg("The " + card.name + " perishes.");
        } else {
          msg("The " + card.name + " counter-attacks for " + (card.attack - player.stats.defense) + " damage.");
          msg("Discarding.");
          return player.hp -= card.attack - player.stats.defense;
        }
      } else {
        msg("The " + card.name + " attacks first, dealing " + card.attack + " damage.");
        msg("Discarding.");
        return player.hp -= card.attack - player.stats.defense;
      }
    }
  };

  config = {
    channels: ['##the_basement'],
    server: 'irc.freenode.net',
    botName: 'MineGames'
  };

  bot = new irc.Client(config.server, config.botName, {
    channels: config.channels
  });

  msg = function(text) {
    return bot.say(config.channels[0], text);
  };

  bot.addListener("message", function(from, to, text, message) {
    if (/^[!](.*)$/.test(text)) {
      switch (text.match(/^[!](\S*).*$/)[1]) {
        case 'join':
          return join(from);
        case 'start':
          return start();
        case 'hand':
          return list_hand(from);
        case 'mine':
          return mine_card(from);
        case 'info':
          return card_info(text.match(/^[!](\S*)\s?(.*)$/)[2]);
        case 'use':
          return use(text.match(/^[!](\S*)\s?(.*)$/)[2], from);
        case 'end':
          return end_turn(from);
        case 'help':
          return help();
      }
    }
  });

}).call(this);

// Generated by CoffeeScript 1.4.0
(function() {
  var Armor, Card, Gem, Item, Monster, Player, Weapon, attack, bot, card_info, cards, check_turn, config, end_turn, generate_cards, help, irc, join, list_hand, mine, mine_card, monster, monster_attack, msg, next_turn, player_nicks, players, shop, start, started, turn, use,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  require('./lib/extend');

  irc = require('irc');

  players = [];

  player_nicks = [];

  started = false;

  mine = [];

  shop = [];

  turn = 0;

  monster = {
    hp: 0,
    card: {}
  };

  Player = (function() {

    function Player(name) {
      this.name = name;
      this.deck = [];
      this.hp = 100;
      this.level = 1;
      this.attack = 3;
      this.defense = 0;
      this.dead = false;
      this.hand = [];
      this.stats = {
        level: this.level,
        attack: this.attack,
        mine: 0,
        value: 0,
        defense: 0
      };
    }

    Player.prototype.addCards = function(cards) {
      var card, _i, _len, _results;
      if (cards.length) {
        _results = [];
        for (_i = 0, _len = cards.length; _i < _len; _i++) {
          card = cards[_i];
          _results.push(this.deck.push(card));
        }
        return _results;
      } else {
        return this.deck.push(cards);
      }
    };

    Player.prototype.draw = function(i) {
      var card, j, _i, _results;
      if (i == null) {
        i = 1;
      }
      _results = [];
      for (j = _i = 1; 1 <= i ? _i <= i : _i >= i; j = 1 <= i ? ++_i : --_i) {
        card = this.deck.pop();
        this.hand.push(card);
        this.stats.mine += card.mine;
        _results.push(this.stats.value += card.value);
      }
      return _results;
    };

    Player.prototype.discard = function(c) {
      var card;
      card = this.hand.splice(this.hand.indexOf(c), 1)[0];
      this.deck.push(card);
      this.stats.mine -= card.mine;
      return this.stats.value -= card.value;
    };

    Player.prototype.deal = function() {
      return this.draw(5);
    };

    return Player;

  })();

  Card = (function() {

    function Card(options) {
      this.name = options.name || 'No name';
      this.cost = 0;
      this.value = 0;
      this.actions = [];
      this.attack = 0;
      this.defense = 0;
      this.mine = 0;
      this.level = 0;
      this.description = "";
      this.action = function() {
        return msg("That card has no action.");
      };
      this.init(options);
    }

    return Card;

  })();

  Gem = (function(_super) {

    __extends(Gem, _super);

    function Gem() {
      return Gem.__super__.constructor.apply(this, arguments);
    }

    Gem.prototype.init = function(options) {
      var _ref;
      this.type = 'gem';
      this.value = options.value;
      return this.description = (_ref = options.description) != null ? _ref : "Used at the shop to buy more cards.";
    };

    return Gem;

  })(Card);

  Weapon = (function(_super) {

    __extends(Weapon, _super);

    function Weapon() {
      return Weapon.__super__.constructor.apply(this, arguments);
    }

    Weapon.prototype.init = function(options) {
      var _ref;
      this.type = 'weapon';
      this.attack = options.attack;
      this.cost = options.cost;
      this.action = options.action;
      return this.description = (_ref = options.description) != null ? _ref : "Can be used to attack Monsters or other Players.";
    };

    return Weapon;

  })(Card);

  Armor = (function(_super) {

    __extends(Armor, _super);

    function Armor() {
      return Armor.__super__.constructor.apply(this, arguments);
    }

    Armor.prototype.init = function(options) {
      var _ref;
      this.type = 'armor';
      this.defense = options.defense;
      this.cost = options.cost;
      return this.description = (_ref = options.description) != null ? _ref : "Used to defend against attacks.";
    };

    return Armor;

  })(Card);

  Item = (function(_super) {

    __extends(Item, _super);

    function Item() {
      return Item.__super__.constructor.apply(this, arguments);
    }

    Item.prototype.init = function(options) {
      this.type = 'item';
      this.cost = options.cost;
      this.mine = options.mine;
      this.action = options.action;
      return this.description = options.description;
    };

    return Item;

  })(Card);

  Monster = (function(_super) {

    __extends(Monster, _super);

    function Monster() {
      return Monster.__super__.constructor.apply(this, arguments);
    }

    Monster.prototype.init = function(options) {
      var _ref;
      this.type = 'monster';
      this.level = options.level;
      this.hp = options.hp;
      this.attack = options.attack;
      this.description = options.description;
      return this.loot = (_ref = options.loot) != null ? _ref : [];
    };

    return Monster;

  })(Card);

  cards = {
    find: function(text) {
      var key, value;
      for (key in this) {
        value = this[key];
        if (this[key].name.toLowerCase() === text) {
          return this[key];
        }
      }
    },
    rock: new Gem({
      name: 'Rock',
      value: 0
    }),
    copper: new Gem({
      name: 'Copper',
      value: 1
    }),
    silver: new Gem({
      name: 'Silver',
      value: 2
    }),
    gold: new Gem({
      name: 'Gold',
      value: 3
    }),
    diamond: new Gem({
      name: 'Diamond',
      value: 5
    }),
    dagger: new Weapon({
      name: 'Dagger',
      attack: 3,
      cost: 3,
      action: function(player, discard) {
        return attack(player, this.attack + player.attack, discard);
      }
    }),
    pickaxe: new Item({
      name: 'Pickaxe',
      cost: 3,
      mine: 1,
      description: "Used to draw cards from the Mine.",
      action: function(player, discard) {
        if (monster.hp > 0) {
          return msg('You cannot mine while there is a monster on the table.');
        } else {
          mine_card(player);
          return discard();
        }
      }
    }),
    potion: new Item({
      name: 'Potion',
      cost: 3,
      description: "Restores 5 HP.",
      action: function(player) {
        return msg("Program me!");
      }
    }),
    goblin: new Monster({
      name: 'Goblin',
      level: 1,
      hp: 6,
      attack: 3,
      description: "Cretins with big ears and fangs. Strong and stupid.",
      loot: [['rock', 2], ['copper', 5], ['potion', 1], [0, 2]]
    })
  };

  generate_cards = function() {
    var i, player, _i, _j, _k, _l, _len, _m, _n, _o, _p, _q, _r, _results, _s, _t, _u;
    for (i = _i = 1; _i <= 10; i = ++_i) {
      mine.push(cards.rock);
    }
    for (i = _j = 1; _j <= 15; i = ++_j) {
      mine.push(cards.copper);
    }
    for (i = _k = 1; _k <= 50; i = ++_k) {
      mine.push(cards.goblin);
    }
    for (i = _l = 1; _l <= 10; i = ++_l) {
      mine.push(cards.silver);
    }
    for (i = _m = 1; _m <= 7; i = ++_m) {
      mine.push(cards.gold);
    }
    for (i = _n = 1; _n <= 5; i = ++_n) {
      mine.push(cards.diamond);
    }
    mine.shuffle();
    for (i = _o = 1; _o <= 10; i = ++_o) {
      shop.push(cards.pickaxe);
    }
    for (i = _p = 1; _p <= 10; i = ++_p) {
      shop.push(cards.potion);
    }
    for (i = _q = 1; _q <= 10; i = ++_q) {
      shop.push(cards.dagger);
    }
    _results = [];
    for (_r = 0, _len = players.length; _r < _len; _r++) {
      player = players[_r];
      for (i = _s = 1; _s <= 5; i = ++_s) {
        player.deck.push(cards.copper);
      }
      for (i = _t = 1; _t <= 2; i = ++_t) {
        player.deck.push(cards.dagger);
      }
      for (i = _u = 1; _u <= 3; i = ++_u) {
        player.deck.push(cards.pickaxe);
      }
      player.deck.shuffle();
      _results.push(player.deal());
    }
    return _results;
  };

  next_turn = function() {
    turn++;
    if (turn >= players.length) {
      turn = 0;
    }
    if (players[turn].dead) {
      return next_turn();
    } else {
      msg("" + players[turn].name + ": It's your turn!");
      return list_hand(players[turn].name);
    }
  };

  check_turn = function(player, cb) {
    if (turn === players.indexOf(player) && started) {
      return cb();
    }
  };

  monster_attack = function() {
    var player;
    if (monster.hp > 0) {
      player = players[turn];
      msg("the " + monster.card.name + " attacks dealing " + (monster.card.attack - player.defense) + " damage.");
      return player.hp -= monster.card.attack - player.defense;
    }
  };

  join = function(nick) {
    if (__indexOf.call(player_nicks, nick) < 0) {
      players.push(new Player(nick));
      player_nicks.push(nick);
      return msg("" + nick + " joined the game!");
    }
  };

  start = function() {
    if (players.length > 0 && !started) {
      generate_cards();
      msg("Starting game!");
      started = true;
      return next_turn();
    } else if (started) {
      return msg("The game's already started.");
    }
  };

  list_hand = function(nick) {
    var card, card_list, player, _fn, _i, _len, _ref;
    if (started) {
      player = players[player_nicks.indexOf(nick)];
      card_list = "";
      _ref = player.hand;
      _fn = function(card) {
        return card_list = "" + card_list + " [" + card.name + "]";
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        _fn(card);
      }
      msg(("" + nick + "'s hand: ") + card_list);
      return msg(("" + nick + "'s stats: ") + ("[Lv: " + player.stats.level + "] ") + ("[HP: " + player.hp + "] ") + ("[Attack: " + player.stats.attack + "] ") + ("[Mines: " + player.stats.mine + "] ") + ("[Money: " + player.stats.value + "]"));
    } else {
      return msg("" + nick + ", the game hasn't started yet.");
    }
  };

  use = function(text, nick) {
    var player;
    player = players[player_nicks.indexOf(nick)];
    return check_turn(player, function() {
      var card, _i, _len, _ref, _results;
      text = text.toLowerCase();
      _ref = player.hand;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        if (card.name.toLowerCase() === text) {
          card.action(player, function() {
            return player.discard(card);
          });
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  };

  end_turn = function(nick) {
    var player;
    player = players[player_nicks.indexOf(nick)];
    return check_turn(player, function() {
      var card, _i, _len, _ref;
      _ref = player.hand;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        player.discard(card);
      }
      player.deck.shuffle();
      player.draw(5);
      return next_turn();
    });
  };

  card_info = function(text) {
    var card, info_text, key, value, _results;
    text = text.toLowerCase();
    _results = [];
    for (key in cards) {
      value = cards[key];
      if (cards[key].name.toLowerCase() === text) {
        card = cards[key];
        info_text = "" + card.name + ": [\"" + card.description + "\"] [type: " + card.type + "]";
        for (key in card) {
          value = card[key];
          if (typeof value === 'number' && value !== 0) {
            info_text += " [" + key + ": " + value + "]";
          }
        }
        _results.push(msg(info_text));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  help = function() {
    msg("Available commands: ");
    msg("!join: Join the game if it's not already in progress.");
    msg("!start: Start the game.");
    msg("!hand: View your current hand.");
    msg("!info [card name]: View details of a particular card.");
    msg("!use [card name]: Use a particular card in your hand.");
    return msg("!end: End your turn.");
  };

  mine_card = function(player) {
    var card;
    card = mine.pop();
    msg("You drew a " + card.name + " from the Mine!");
    if (card.type === 'gem') {
      msg("Putting it in your deck.");
      return player.deck.push(card);
    } else {
      monster.card = card;
      monster.hp = card.hp;
      if (Math.floor(Math.random() * 2)) {
        return msg("Preemptive strike! You attack first");
      } else {
        msg("Back attack!");
        return monster_attack();
      }
    }
  };

  attack = function(player, dmg, discard) {
    var card, card_index, drop, drops, i, odds, _i, _j, _len, _ref, _ref1;
    if (monster.hp > 0) {
      msg("You attack the " + monster.card.name + ", dealing " + (dmg - monster.card.defense) + " damage.");
      monster.hp -= dmg - monster.card.defense;
      discard();
      if (monster.hp < 1) {
        msg("The " + monster.card.name + " perishes.");
        drops = [];
        odds = 0;
        _ref = monster.card.loot;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          card = _ref[_i];
          for (i = _j = 1, _ref1 = card[1]; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
            drops.push(card[0]);
          }
          odds += card[1];
        }
        card_index = Math.floor(Math.random() * (odds + 1));
        drop = drops[card_index];
        if (drop) {
          drop = cards.find(drop);
          msg("The " + monster.card.name + " dropped a " + drop.name + "! Putting it in your deck.");
          player.deck.push(drop);
        }
        monster.hp = 0;
        return monster.card = {};
      } else {
        return monster_attack();
      }
    } else {
      return msg("There is no Monster on the table.");
    }
  };

  config = {
    channels: ['##mine_games'],
    server: 'irc.freenode.net',
    botName: 'MineGames'
  };

  bot = new irc.Client(config.server, config.botName, {
    channels: config.channels
  });

  msg = function(text) {
    return bot.say(config.channels[0], text);
  };

  bot.addListener("message", function(from, to, text, message) {
    if (/^[!](.*)$/.test(text)) {
      switch (text.match(/^[!](\S*).*$/)[1]) {
        case 'join':
          return join(from);
        case 'start':
          return start();
        case 'hand':
          return list_hand(from);
        case 'mine':
          return mine_card(from);
        case 'info':
          return card_info(text.match(/^[!](\S*)\s?(.*)$/)[2]);
        case 'use':
          return use(text.match(/^[!](\S*)\s?(.*)$/)[2], from);
        case 'end':
          return end_turn(from);
        case 'help':
          return help();
      }
    }
  });

}).call(this);

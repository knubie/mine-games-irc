// Generated by CoffeeScript 1.4.0
(function() {
  var Armor, Card, Gem, Item, Monster, Player, Weapon, attack, bot, buy, card_info, cards, check_turn, config, drop_loot, end_turn, generate_cards, help, irc, join, list_hand, list_shop, mine, mine_card, monster, monster_attack, msg, next_turn, notice, player_nicks, players, shop, start, started, turn, use,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  require('./lib/extend');

  irc = require('irc');

  players = [];

  player_nicks = [];

  started = false;

  mine = [];

  shop = [];

  turn = 0;

  monster = {
    hp: 0,
    card: {}
  };

  Player = (function() {

    function Player(name) {
      this.name = name;
      this.deck = [];
      this.hp = 100;
      this.level = 1;
      this.attack = 3;
      this.defense = 0;
      this.dead = false;
      this.hand = [];
      this.stats = {
        level: this.level,
        attack: this.attack,
        mine: 0,
        value: 0,
        defense: 0
      };
    }

    Player.prototype.draw = function(i) {
      var card, j, _i, _results;
      if (i == null) {
        i = 1;
      }
      _results = [];
      for (j = _i = 1; 1 <= i ? _i <= i : _i >= i; j = 1 <= i ? ++_i : --_i) {
        card = this.deck.pop();
        this.hand.push(card);
        this.stats.mine += card.mine;
        _results.push(this.stats.value += card.value);
      }
      return _results;
    };

    Player.prototype.discard = function(c) {
      var card;
      card = this.hand.splice(this.hand.indexOf(c), 1)[0];
      this.deck.push(card);
      this.stats.mine -= card.mine;
      return this.stats.value -= card.value;
    };

    Player.prototype.deal = function() {
      return this.draw(5);
    };

    Player.prototype.fight = function(dmg, discard) {
      if (monster.hp > 0) {
        msg("You attack the " + monster.card.name + ", dealing " + (this.attack + dmg - monster.card.defense) + " damage.");
        monster.hp -= this.attack + dmg - monster.card.defense;
        discard();
        if (monster.hp < 1) {
          msg("The " + monster.card.name + " perishes.");
          drop_loot();
          monster.hp = 0;
          return monster.card = {};
        } else {
          return monster_attack();
        }
      } else {
        return msg("There is no Monster on the table.");
      }
    };

    return Player;

  })();

  Card = (function() {

    function Card(options) {
      this.name = options.name || 'No name';
      this.cost = 0;
      this.value = 0;
      this.actions = [];
      this.attack = 0;
      this.defense = 0;
      this.mine = 0;
      this.level = 0;
      this.description = "";
      this.action = function() {
        return msg("That card has no action.");
      };
      this.init(options);
    }

    return Card;

  })();

  Gem = (function(_super) {

    __extends(Gem, _super);

    function Gem() {
      return Gem.__super__.constructor.apply(this, arguments);
    }

    Gem.prototype.init = function(options) {
      var _ref;
      this.type = 'gem';
      this.value = options.value;
      return this.description = (_ref = options.description) != null ? _ref : "Used at the shop to buy more cards.";
    };

    return Gem;

  })(Card);

  Weapon = (function(_super) {

    __extends(Weapon, _super);

    function Weapon() {
      return Weapon.__super__.constructor.apply(this, arguments);
    }

    Weapon.prototype.init = function(options) {
      var _ref;
      this.type = 'weapon';
      this.attack = options.attack;
      this.cost = options.cost;
      this.action = options.action;
      return this.description = (_ref = options.description) != null ? _ref : "Can be used to attack Monsters or other Players.";
    };

    return Weapon;

  })(Card);

  Armor = (function(_super) {

    __extends(Armor, _super);

    function Armor() {
      return Armor.__super__.constructor.apply(this, arguments);
    }

    Armor.prototype.init = function(options) {
      var _ref;
      this.type = 'armor';
      this.defense = options.defense;
      this.cost = options.cost;
      return this.description = (_ref = options.description) != null ? _ref : "Used to defend against attacks.";
    };

    return Armor;

  })(Card);

  Item = (function(_super) {

    __extends(Item, _super);

    function Item() {
      return Item.__super__.constructor.apply(this, arguments);
    }

    Item.prototype.init = function(options) {
      this.type = 'item';
      this.cost = options.cost;
      this.mine = options.mine;
      this.action = options.action;
      return this.description = options.description;
    };

    return Item;

  })(Card);

  Monster = (function(_super) {

    __extends(Monster, _super);

    function Monster() {
      return Monster.__super__.constructor.apply(this, arguments);
    }

    Monster.prototype.init = function(options) {
      var _ref;
      this.type = 'monster';
      this.level = options.level;
      this.hp = options.hp;
      this.attack = options.attack;
      this.description = options.description;
      return this.loot = (_ref = options.loot) != null ? _ref : [];
    };

    return Monster;

  })(Card);

  cards = {
    find: function(text) {
      var key, value;
      for (key in this) {
        value = this[key];
        if (this[key].name.toLowerCase() === text) {
          return this[key];
        }
      }
    },
    rock: new Gem({
      name: 'Rock',
      value: 0
    }),
    copper: new Gem({
      name: 'Copper',
      value: 1
    }),
    silver: new Gem({
      name: 'Silver',
      value: 2
    }),
    gold: new Gem({
      name: 'Gold',
      value: 3
    }),
    diamond: new Gem({
      name: 'Diamond',
      value: 5
    }),
    dagger: new Weapon({
      name: 'Dagger',
      attack: 3,
      cost: 3,
      action: function(player, discard) {
        return player.fight(this.attack, discard);
      }
    }),
    sword: new Weapon({
      name: 'Sword',
      attack: 5,
      cost: 5,
      action: function(player, discard) {
        return player.fight(this.attack, discard);
      }
    }),
    fire: new Weapon({
      name: 'Fire',
      attack: 10,
      cost: 10,
      action: function(player, discard) {
        return player.fight(this.attack, discard);
      }
    }),
    pickaxe: new Item({
      name: 'Pickaxe',
      cost: 3,
      mine: 1,
      description: "Used to draw cards from the Mine.",
      action: function(player, discard) {
        if (monster.hp > 0) {
          return msg('You cannot mine while there is a monster on the table.');
        } else {
          mine_card(player);
          return discard();
        }
      }
    }),
    potion: new Item({
      name: 'Potion',
      cost: 3,
      description: "Restores 5 HP.",
      action: function(player) {
        player.hp += 5;
        return msg("" + player.name + " restores 5 HP.");
      }
    }),
    knapsack: new Item({
      name: 'Knapsack',
      cost: 3,
      description: "Draw one card from your deck.",
      actions: function(player) {
        msg("You drew a " + player.deck[player.deck.length - 1] + " and put it in your hand.");
        return player.draw();
      }
    }),
    goblin: new Monster({
      name: 'Goblin',
      level: 1,
      hp: 12,
      attack: 3,
      description: "Cretins with big ears and fangs. Strong and stupid.",
      loot: [['rock', 2], ['copper', 5], ['potion', 1], [0, 2]]
    }),
    bats: new Monster({
      name: 'Bats',
      level: 1,
      hp: 12,
      attack: 4,
      description: "Weak to light-based spells.",
      loot: [['rock', 2], ['copper', 5], ['potion', 1], [0, 2]]
    }),
    undead: new Monster({
      name: 'Undead',
      level: 1,
      hp: 20,
      attack: 4,
      description: "Tourmented souls, immune to life draining spells.",
      loot: [['silver', 2], ['copper', 5], ['potion', 1], [0, 2]]
    }),
    golem: new Monster({
      name: 'Golem',
      level: 1,
      hp: 30,
      attack: 10,
      description: "A giant made entirely of rock. Weak to wind-based spells.",
      loot: [['gold', 2], ['silver', 5], ['dagger', 1], [0, 2]]
    }),
    wyrm: new Monster({
      name: 'Wyrm',
      level: 1,
      hp: 50,
      attack: 15,
      description: "A fierce dragon that slumbers in the depths of the cave.",
      loot: [['diamond', 2], ['gold', 5], ['sword', 1], [0, 2]]
    })
  };

  generate_cards = function() {
    var i, mine1, mine2, mine3, mine4, player, _aa, _ab, _ac, _i, _j, _k, _l, _len, _m, _n, _o, _p, _q, _r, _results, _s, _t, _u, _v, _w, _x, _y, _z;
    mine1 = [];
    mine2 = [];
    mine3 = [];
    mine4 = [];
    for (i = _i = 1; _i <= 5; i = ++_i) {
      mine1.push(cards.goblin);
    }
    for (i = _j = 1; _j <= 2; i = ++_j) {
      mine1.push(cards.bats);
    }
    for (i = _k = 1; _k <= 2; i = ++_k) {
      mine1.push(cards.copper);
    }
    mine1.shuffle();
    for (i = _l = 1; _l <= 3; i = ++_l) {
      mine2.push(cards.bats);
    }
    for (i = _m = 1; _m <= 5; i = ++_m) {
      mine2.push(cards.undead);
    }
    for (i = _n = 1; _n <= 3; i = ++_n) {
      mine2.push(cards.copper);
    }
    for (i = _o = 1; _o <= 3; i = ++_o) {
      mine2.push(cards.silver);
    }
    mine2.shuffle();
    for (i = _p = 1; _p <= 3; i = ++_p) {
      mine3.push(cards.gold);
    }
    for (i = _q = 1; _q <= 5; i = ++_q) {
      mine3.push(cards.golem);
    }
    mine3.shuffle();
    for (i = _r = 1; _r <= 5; i = ++_r) {
      mine4.push(cards.wyrm);
    }
    for (i = _s = 1; _s <= 2; i = ++_s) {
      mine4.push(cards.diamond);
    }
    mine4.shuffle();
    mine = mine4.concat(mine3, mine2, mine1);
    for (i = _t = 1; _t <= 10; i = ++_t) {
      shop.push(cards.pickaxe);
    }
    for (i = _u = 1; _u <= 10; i = ++_u) {
      shop.push(cards.potion);
    }
    for (i = _v = 1; _v <= 10; i = ++_v) {
      shop.push(cards.knapsack);
    }
    for (i = _w = 1; _w <= 10; i = ++_w) {
      shop.push(cards.dagger);
    }
    for (i = _x = 1; _x <= 10; i = ++_x) {
      shop.push(cards.sword);
    }
    for (i = _y = 1; _y <= 10; i = ++_y) {
      shop.push(cards.fire);
    }
    _results = [];
    for (_z = 0, _len = players.length; _z < _len; _z++) {
      player = players[_z];
      for (i = _aa = 1; _aa <= 5; i = ++_aa) {
        player.deck.push(cards.copper);
      }
      for (i = _ab = 1; _ab <= 2; i = ++_ab) {
        player.deck.push(cards.dagger);
      }
      for (i = _ac = 1; _ac <= 3; i = ++_ac) {
        player.deck.push(cards.pickaxe);
      }
      player.deck.shuffle();
      _results.push(player.deal());
    }
    return _results;
  };

  next_turn = function() {
    turn++;
    if (turn >= players.length) {
      turn = 0;
    }
    if (players[turn].dead) {
      return next_turn();
    } else {
      msg("" + players[turn].name + ": It's your turn!");
      return list_hand(players[turn].name);
    }
  };

  check_turn = function(player, cb) {
    if (turn === players.indexOf(player) && started) {
      return cb();
    }
  };

  monster_attack = function() {
    var player;
    if (monster.hp > 0) {
      player = players[turn];
      msg("the " + monster.card.name + " attacks dealing " + (monster.card.attack - player.defense) + " damage.");
      return player.hp -= monster.card.attack - player.defense;
    }
  };

  join = function(nick) {
    if (__indexOf.call(player_nicks, nick) < 0) {
      players.push(new Player(nick));
      player_nicks.push(nick);
      return msg("" + nick + " joined the game!");
    }
  };

  start = function() {
    if (players.length > 0 && !started) {
      generate_cards();
      msg("Starting game!");
      started = true;
      return next_turn();
    } else if (started) {
      return msg("The game's already started.");
    }
  };

  list_hand = function(nick) {
    var card, card_list, player, _fn, _i, _len, _ref;
    if (started) {
      player = players[player_nicks.indexOf(nick)];
      card_list = "";
      _ref = player.hand;
      _fn = function(card) {
        return card_list = "" + card_list + " [" + card.name + "]";
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        _fn(card);
      }
      notice(nick, "Hand: " + card_list);
      return notice(nick, "Stats: " + ("[Lv: " + player.stats.level + "] ") + ("[HP: " + player.hp + "] ") + ("[Attack: " + player.stats.attack + "] ") + ("[Mines: " + player.stats.mine + "] ") + ("[Money: " + player.stats.value + "]"));
    } else {
      return msg("" + nick + ", the game hasn't started yet.");
    }
  };

  list_shop = function(nick) {
    var card, card_list, count, curr_card, player, _i, _len;
    if (started) {
      player = players[player_nicks.indexOf(nick)];
      card_list = "";
      curr_card = {};
      count = 0;
      for (_i = 0, _len = shop.length; _i < _len; _i++) {
        card = shop[_i];
        if (card === curr_card) {
          count++;
        } else {
          if (curr_card.name) {
            card_list = card_list + (" [" + curr_card.name + " | $" + curr_card.cost + " | " + count + "/10]");
          }
          curr_card = card;
          count = 1;
        }
      }
      card_list = card_list + (" [" + curr_card.name + " | $" + curr_card.cost + " | " + count + "/10]");
      return msg("Shop inventory:" + card_list);
    } else {
      return msg("" + nick + ", the game hasn't started yet.");
    }
  };

  buy = function(text, nick) {
    var player;
    player = players[player_nicks.indexOf(nick)];
    return check_turn(player, function() {
      var card;
      card = cards.find(text);
      player = players[turn];
      if (shop.indexOf(card !== -1)) {
        if (player.stats.value >= card.cost) {
          player.deck.push(shop.splice(shop.indexOf(card), 1)[0]);
          player.stats.value -= card.cost;
          return msg("You bought a " + card.name + ", putting it in your deck.");
        } else {
          return msg("Not enough money.");
        }
      }
    });
  };

  use = function(text, nick) {
    var player;
    player = players[player_nicks.indexOf(nick)];
    return check_turn(player, function() {
      var card, _i, _len, _ref, _results;
      text = text.toLowerCase();
      _ref = player.hand;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        if (card.name.toLowerCase() === text) {
          card.action(player, function() {
            return player.discard(card);
          });
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  };

  end_turn = function(nick) {
    var player;
    player = players[player_nicks.indexOf(nick)];
    return check_turn(player, function() {
      var card, _i, _len, _ref;
      _ref = player.hand;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        player.discard(card);
      }
      player.deck.shuffle();
      player.draw(5);
      return next_turn();
    });
  };

  card_info = function(text) {
    var card, info_text, key, value, _results;
    text = text.toLowerCase();
    _results = [];
    for (key in cards) {
      value = cards[key];
      if (cards[key].name.toLowerCase() === text) {
        card = cards[key];
        info_text = "" + card.name + ": [\"" + card.description + "\"] [type: " + card.type + "]";
        for (key in card) {
          value = card[key];
          if (typeof value === 'number' && value !== 0) {
            info_text += " [" + key + ": " + value + "]";
          }
        }
        _results.push(msg(info_text));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  help = function() {
    msg("Available commands: ");
    msg("!join: Join the game if it's not already in progress.");
    msg("!start: Start the game.");
    msg("!hand: View your current hand.");
    msg("!shop: View shop inventory.");
    msg("!info [card name]: View details of a particular card.");
    msg("!use [card name]: Use a particular card in your hand.");
    return msg("!end: End your turn.");
  };

  mine_card = function(player) {
    var card;
    card = mine.pop();
    msg("You drew a " + card.name + " from the Mine!");
    if (card.type === 'gem') {
      msg("Putting it in your deck.");
      return player.deck.push(card);
    } else {
      monster.card = card;
      monster.hp = card.hp;
      if (Math.floor(Math.random() * 2)) {
        return msg("Preemptive strike! You attack first");
      } else {
        msg("Back attack!");
        return monster_attack();
      }
    }
  };

  attack = function(player, dmg, discard) {
    if (monster.hp > 0) {
      msg("You attack the " + monster.card.name + ", dealing " + (dmg - monster.card.defense) + " damage.");
      monster.hp -= dmg - monster.card.defense;
      discard();
      if (monster.hp < 1) {
        msg("The " + monster.card.name + " perishes.");
        drop_loot();
        monster.hp = 0;
        return monster.card = {};
      } else {
        return monster_attack();
      }
    } else {
      return msg("There is no Monster on the table.");
    }
  };

  drop_loot = function() {
    var card, card_index, drop, drops, i, odds, _i, _j, _len, _ref, _ref1;
    drops = [];
    odds = 0;
    _ref = monster.card.loot;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      card = _ref[_i];
      for (i = _j = 1, _ref1 = card[1]; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        drops.push(card[0]);
      }
      odds += card[1];
    }
    card_index = Math.floor(Math.random() * (odds + 1));
    drop = drops[card_index];
    if (drop) {
      drop = cards.find(drop);
      msg("The " + monster.card.name + " dropped a " + drop.name + "! Putting it in your deck.");
      return players[turn].deck.push(drop);
    }
  };

  config = {
    channels: ['##mine_games'],
    server: 'irc.freenode.net',
    botName: 'MineGames'
  };

  bot = new irc.Client(config.server, config.botName, {
    channels: config.channels
  });

  msg = function(text) {
    return bot.say(config.channels[0], "/me | " + text);
  };

  notice = function(nick, text) {
    return bot.notice(nick, text);
  };

  bot.addListener("message", function(from, to, text, message) {
    if (/^[!](.*)$/.test(text)) {
      switch (text.match(/^[!](\S*).*$/)[1]) {
        case 'join':
          return join(from);
        case 'start':
          return start();
        case 'hand':
          return list_hand(from);
        case 'shop':
          return list_shop(from);
        case 'mine':
          return mine_card(from);
        case 'info':
          return card_info(text.match(/^[!](\S*)\s?(.*)$/)[2]);
        case 'use':
          return use(text.match(/^[!](\S*)\s?(.*)$/)[2], from);
        case 'buy':
          return buy(text.match(/^[!](\S*)\s?(.*)$/)[2], from);
        case 'end':
          return end_turn(from);
        case 'help':
          return help();
      }
    }
  });

}).call(this);
